[{"name":"Any.Dict","comment":"\n\n\n# Data\n\n@docs Dict\n\n\n# Interface\n\n@docs Interface\n\n@docs makeInterface\n\n","unions":[{"name":"Dict","comment":" An (almost) drop-in replacement for elm/core's Dict data structure; the\ndifference is that keys can be any type, not just `comparable`.\n\n(When I say \"any\" type, there's one proviso: you must be able to provide a pair\nof functions that can convert your key type into a `comparable` and back\nagain. So this won't work with functions, but it will work with custom types.)\n\n","args":["k","v","comparable"],"cases":[]}],"aliases":[{"name":"Interface","comment":" A big old record of functions that mirror the interface of elm/core's Dict\ndata structure. The type variables look a bit scary but in practice you won't\nusually need to include an `Interface` in your type annotations, so you can\nignore them.\n","args":["k","v","v2","output","comparable"],"type":"{ empty : Any.Dict.Dict k v comparable, singleton : k -> v -> Any.Dict.Dict k v comparable, insert : k -> v -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, update : k -> (Maybe.Maybe v -> Maybe.Maybe v) -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, remove : k -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, isEmpty : Any.Dict.Dict k v comparable -> Basics.Bool, member : k -> Any.Dict.Dict k v comparable -> Basics.Bool, get : k -> Any.Dict.Dict k v comparable -> Maybe.Maybe v, size : Any.Dict.Dict k v comparable -> Basics.Int, keys : Any.Dict.Dict k v comparable -> List.List k, values : Any.Dict.Dict k v comparable -> List.List v, toList : Any.Dict.Dict k v comparable -> List.List ( k, v ), fromList : List.List ( k, v ) -> Any.Dict.Dict k v comparable, map : (k -> v -> v2) -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v2 comparable, foldl : (k -> v -> output -> output) -> output -> Any.Dict.Dict k v comparable -> output, foldr : (k -> v -> output -> output) -> output -> Any.Dict.Dict k v comparable -> output, filter : (k -> v -> Basics.Bool) -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, partition : (k -> v -> Basics.Bool) -> Any.Dict.Dict k v comparable -> ( Any.Dict.Dict k v comparable, Any.Dict.Dict k v comparable ), union : Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, intersect : Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, diff : Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v comparable, merge : (k -> v -> output -> output) -> (k -> v -> v2 -> output -> output) -> (k -> v2 -> output -> output) -> Any.Dict.Dict k v comparable -> Any.Dict.Dict k v2 comparable -> output -> output }"}],"values":[{"name":"makeInterface","comment":" Use `makeInterface` to define an `Interface` for your custom `Dict`\ntype. You need to supply two functions:\n\n1.  `toComparable`, which converts your key type into any `comparable` type (e.g.\n    `Int`, `String`, `Float`, or a tuple containing only `comparable` types)\n2.  `fromComparable`, which converts that same `comparable` type back into your\n    key type.\n\nFor example:\n\n\n    type Colour\n        = Red\n        | Green\n        | Blue\n\n    colourToInt c =\n        case c of\n            Red ->\n                0\n\n            Green ->\n                1\n\n            Blue ->\n                2\n\n    colourFromInt i =\n        case i of\n            0 ->\n                Red\n\n            1 ->\n                Green\n\n            _ ->\n                Blue\n\n    colourDict =\n        makeInterface\n            { toComparable = colourToInt\n            , fromComparable = colourFromInt\n            }\n\n    example =\n        colourDict.fromList\n            [ ( Red, \"This is red!\" )\n            , ( Blue, \"This is blue!\" )\n            ]\n\n    -- colourDict.get Red example == Just \"This is red!\"\n\n","type":"{ toComparable : k -> comparable, fromComparable : comparable -> k } -> Any.Dict.Interface k v v2 output comparable"}],"binops":[]},{"name":"Any.Set","comment":"\n\n\n# Data\n\n@docs Set\n\n\n# Interface\n\n@docs Interface\n\n@docs makeInterface\n\n","unions":[{"name":"Set","comment":" Explain this!\n","args":["a","comparable"],"cases":[]}],"aliases":[{"name":"Interface","comment":" Explain this!\n","args":["a","b","output","comparable"],"type":"{ empty : Any.Set.Set a comparable, singleton : a -> Any.Set.Set a comparable, insert : a -> Any.Set.Set a comparable -> Any.Set.Set a comparable, remove : a -> Any.Set.Set a comparable -> Any.Set.Set a comparable, isEmpty : Any.Set.Set a comparable -> Basics.Bool, member : a -> Any.Set.Set a comparable -> Basics.Bool, size : Any.Set.Set a comparable -> Basics.Int, union : Any.Set.Set a comparable -> Any.Set.Set a comparable -> Any.Set.Set a comparable, intersect : Any.Set.Set a comparable -> Any.Set.Set a comparable -> Any.Set.Set a comparable, diff : Any.Set.Set a comparable -> Any.Set.Set a comparable -> Any.Set.Set a comparable, toList : Any.Set.Set a comparable -> List.List a, fromList : List.List a -> Any.Set.Set a comparable, map : (b -> comparable) -> (a -> b) -> Any.Set.Set a comparable -> Any.Set.Set b comparable, foldl : (a -> output -> output) -> output -> Any.Set.Set a comparable -> output, foldr : (a -> output -> output) -> output -> Any.Set.Set a comparable -> output, filter : (a -> Basics.Bool) -> Any.Set.Set a comparable -> Any.Set.Set a comparable, partition : (a -> Basics.Bool) -> Any.Set.Set a comparable -> ( Any.Set.Set a comparable, Any.Set.Set a comparable ), toggle : a -> Any.Set.Set a comparable -> Any.Set.Set a comparable }"}],"values":[{"name":"makeInterface","comment":" Explain this!\n","type":"{ toComparable : a -> comparable, fromComparable : comparable -> a } -> Any.Set.Interface a b output comparable"}],"binops":[]}]